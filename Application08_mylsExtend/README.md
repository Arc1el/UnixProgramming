# mylsExtend.c

<h3>요구사항</h3>

응용과제 7 확장

-l 옵션을 주는 경우 파일에 대한 자세한 정보 출력 (기본 100점)

(1) 파일 이름을 제외한 나머지 정보 종류마다 +50점

(2) 반드시 각 정보를 얻어낸 방법 자세히 설명

 

파일 이름을 제외한 제공 가능한 정보 반드시 별도로 설명

예 :

(1) UID  정수로 출력 +50점,

(2) UID로 passwd 구조체 찾아 사용자 이름 출력 +50점

<h3>구현</h3>

파일권한을 위해 octarray,perms를 선언해주고 값을 할당해주었습니다. 일반적으로 동작할부분을 normal_print, -l 옵션을 사용해 세부내용을 출력하기위해

detail_print함수를 작성해주었습니다. main에서 argc가 2이하이면 사용법 과 세부사용법을 출력후 종료해줍니다.

argv에서 디렉토리명을 받을것이기 때문에 캐릭터포인터 dirnam을 선언해 주고 getopt를 사용하기위해 opt를 선언해주었습니다.

while문을 사용하여 getopt를 루프시킵니다. 옵션으로 l을 받고 l은 단독적으로 쓰이지 않기 때문에 디렉토리명까지 포함하여 argc가 3인지 검사해줍니다.

조건을 만족하면 dirnam은 argv[2]로 할당됩니다. 그후 detail_print함수를 소출해주었습니다. 이때 매개변수로 argv[2]값인 dirnam이 들어갑니다.

그 외 옵션을 부여하지 않았을때는 getopt루프가 돌지 않습니다. 때문에 메인에 dirnam을 argv[1]로 할당해주었고 이때는 보통 ls 명령을 출력해야하므로

normal_print함수를 호출해주었습니다. 역시 매개변수는 실행파일과 디렉토 리만 받기 때문에 argv[1]값인 dirnam이 들어갑니다.

디렉토리포인터 dp를 선언하고 응용과제 7번과같이 한행에 출력할 수 있는 개수를 제한하기위해 count도 선언해 줍니다.

opendir함수를 사용하여 메인에서 전달받은 dirnam을 열기합니다. 이때의 디렉토리포인터는 dp입니다. 이 때 NULL을 리턴하면 오류메세지를 출력후 종료합니다.

디렉토리 항목을 출력하기위해 dirent.h 헤더에 정의된 구조체 *dent를 선언해줍니다. 반복문을 통해 readdir함수를 호출하고

dp가 가리키는 파일을 dent구조체에 저장합니다. 이는 readdir함수가 더 이상 읽을것이 없을 때 종료될 것입니다.

그후 print문을 사용하여 dent구조체로 d_name에 접근하여 출력합니다. 출력하면 count를 ++하여 나중 에 카운트가 7이되고

이값을 7로나누면 몫이 0이되기에이때 개행을 해줍니다.

반복문이 종료되면 오픈하였던 dp를 닫아줍니다.

<추가한것>

1. 파일의 종류 출력 (p,d,-,l)

반복문의 readdir함수로 dp의 파일을 읽어올때마다 해당 디렉토리의 항목(d_name)을 읽어와 lstat함수를 사용하 여 buf에 정보를 저장해주었습니다.

처음에는 stat함수만 사용했다가 심볼릭 링크항목이 표시되지 않아서 lstat함수 를 사용하였습니다.

저장한 buf.st_mode를 매크로를 이용한 파일종류 검색을통해 피포파일인지, 디렉토리인지, 일반파일인지, 링크파일인지 구분하여

f_type에 p,d,-,l 문자를 저장해주었습니다.

2. 파일의 권한 출력 (rwxrwxrwx)

octarray배열을 선언하고, 0400,0200,0100,0040,0020,0010,0004,0002,0001을 저장합니다.

이는 유저,그룹,기타 사용자의 읽기,쓰기,실행권한입니다. perms배열을 선언하고 rwxrwxrwx를 저 장해줍니다.

권한을 문자열로 출력하 기위해 mode_str를 선언합니다. 그후 반복문을통해 MODE_SIZE만큼 루프해줍니다.

stat_buf.st_mode와 octarray[i] 를 and연산하여 참이면 mode_str[i]에 perms[i]를 저장합니다.

perms는 rwxrwxrwx이므로 해당 하는 권한을 가진다면 해당하는 문자를 mode_str에 저장할것입니다.

만약 아니라면 mode_str 에 - 를 저장합니다. 배 열의 마지막에 널문자를 추가후 출력시 %s로 mode_str를 출력해줍니다.

3. 파일의 링크수 출력

반복문에서 stat함수를통해 디렉토리의 파일항목이름을 반복하여 읽기 때문에 정보를 저장했던 buf구조체의 st_nlink항목만 출력하면됩니다.

출력시 unsined int형으로 buf.st_nlink항목을 출력해주었습니다.

4. 파일의 inode값 출력

반복문에서 stat함수를통해 디렉토리의 파일항목이름을 반복하여 읽기 때문에 정보를 저장했던 buf구조체의 st_ino 항목만 출력하면됩니다.

출력시 int형으로 buf.st_ino항목을 출력해주었습니다.

5. 파일의 소유자 출력

반복문에서 stat함수를 호출하여 buf에 저장하였고 이 buf.st_uid항목이 이 파일의 소유자 uid입니다.

이 uid를 이 름형태로 나타내기위해 pwd.h헤더에 정의된 passwd구조체 *pw를 선언하고

getpwuid함수를 이용해 buf.st_uid에 해당하는 사용자를 찾아 정보를 검색합니다. 출력시 pw포인터를 pw_name에 접근하여 소유자명을 출력해주었습니다.

6. 파일의 소유그룹 출력

반복문에서 stat함수를 호출하여 buf에 저장하였고 이 buf.st_gid항목이 이 파일의 소유그룹 gid입니다.

이 gid를 그룹명 형태로 나타내기위해 grp.h헤더에 정의된 group구조체 *grp를 선언하고

getgrgid함수를 이용해 buf.st_gid 에 해당하는 그룹를 찾아 정보를 검색합니다. 출력시 grp포인터를 gr_name에 접근하여 소유그룹명을 출력해주었습니다.

7. 파일의 크기 출력

반복문에서 stat함수를통해 디렉토리의 파일항목이름을 반복하여 읽기 때문에 정보를 저장했던 buf구조체의 st_size항목만 출력하면됩니다.

출력시 int형으로 buf.st_size항목을 출력해주었습니다.

8. 파일의 마지막수정일 출력

반복문에서 stat함수를 통해 디렉토리의 파일항목을 읽어 해당항목의 mtime을 사용합니다. time.h에 정의되어있는 tm구조체 time을 선언합니다.

그후 localtime함수를 사용하여 파일의 mtime을 time구조체에 저장합니다. lcocaltime함수는 unix timestamp를 년,월,일등의 값을 나타내는 멤버가 있는

time구조체에 대한 포인터를 반환하 는 역할을 합니다. tm구조체는 다음과 같이 time.h에 선언되어있습니다.

```c
struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour; 
  int tm_mday; 
  int tm_mon; 
  int tm_year; 
  int tm_wday; 
  int tm_yday; 
  int tm_isdst;
};
```
이번에는 strftime함수를 사용하여 문자열을 저장하기위해 선언하였던 time_buf에 time_buf의 사이즈만큼 월, 일, 시간, 분을 저장하였던

time구조체에서 불러와 문자열로 저장합니다. 후에 출력시 %s로 time_buf를 출력해줍니다.

9. 링크파일인 경우 원본파일 출력

조건문을 사용하여 S_ISLNK(buf.st_mode)로 심볼릭 링크파일인지 먼저 확인합니다.

심볼릭 링크파일인 경우 readlink함수를 호출하여 디렉토리 파일항목을 lnk_src배열에, BUFSIZ만큼 저장합니다.

이 때 readlink시 오류발생하면 메시지 출력후 3을 출력해줍니다. 문자열 마지막에 널문자를 추가해 문자열조건을 만 족시킵니다.

이렇게하면 lnk배열에 심볼릭 링크파일의 원본파일명이 저장될 것입니다. 그후 ->표시와 함께 %s에 lnk_src를 출력해줍니다.

반복문이 종료되고 closedir함수를이용해 dp를 닫아줍니다.
