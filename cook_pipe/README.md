# Cook program using pipe

![Image of Pipeline](https://github.com/Arc1el/UnixProgramming/blob/master/cook_pipe/cook_pipe.png)

1. 부모는 자식에게 문자열로 메뉴입력받아 파이프로 전달
 - mkfifo를 사용하여 2개의 이름있는 파이프를 생성, 부모자식간 통신에 사용하였습니다. 통신에 사용된 파일디스크립터는 위의 파이프 설계 그림과 같습니다.

2. 자식은 파이프로 문자열을 전달받아 printf로 출력, 부모에게 전달할 문자열을 파이프에 작성
 - 부모에서 fgets함수를 사용하여 stdin으로 메뉴를 입력받고, 부모는 write함수로 파이프에 쓰기하여 자식이 파이프를 통해 메뉴를 전달받을 수 있도록합니다. 자식은 부모에게 문자열을 전달받아 메뉴를 전달받았음을 출력합니다.

3. alrm함수를 사용하여 요리시작
 - alrm함수를 사용하여 알람시간을 매개변수로 넣고 시그널을 발생시킵니다. 이때의 alrm시그널은 미리 작성해둔 알람 핸들러가 처리하게됩니다. (응용 10과 동일)

4. 요리가 끝나면 자식은 0을 반환
 - 0을 반환시키므로써 부모가 wait함수를 사용하여 자식의 종료를 기다리게합니다. 자식이 종료하면서 리턴값을 반환시키면 부모의 wait이후 코드가 동작하게됩니다.

5. 부모가 자식이 종료됨을 확인 후 자식이 파이프에 작성한 문자열을 불러와 비교
 - 부모가 wait함수를 사용하여 자식의 종료를 기다린 후 동작합니다. 자식은 k2c파이프를 사용하여 success라는 문자열을 보내는데, 부모가 success라는 문자열을 받으면 요리를 전달하였다는 출력을 합니다. (strcmp사용)

6. 반복 수행
 - 반복적으로 수행하도록 while(1)반복문을 사용하여 fork를 해주었습니다.
