# scoremanagement.c

<h3>요구사항</h3>

학번, 이름, 국어, 영어, 수학 점수와 총점, 평균을 저장하기 위한 구조체를 정의하고,

파일을 이용하여 성적을 저장하고, 탐색하는 프로그램을 작성하시오.


1. 성적 입력 프로그램 

- 파일 이름을 argument로 전달받아 open

- 프로그램 안에서 반복하여 사용자 입력(학번, 이름, 국어, 영어, 수학 점수)을 받아 총점, 평균을 계산한 후 저장 

 

2. 성적 파일 출력 프로그램 

- 파일 이름을 argument로 전달받아 open

- 파일에 저장된 전체 학생 성적 표 형식(첫 줄 항목 이름 출력, 각 줄 열을 맞추어서)으로 출력 

 

3. 성적 추가 프로그램 

- 파일 이름, 학번, 이름, 국어, 영어, 수학 점수를 argument로 전달받아 총점, 평균을 계산하여 파일에 추가(append)

 

4. 성적 처리 프로그램 

- 파일 이름을 argument로 전달받아 open

- 파일 전체를 읽어서 과목별 총점, 평균, 전체 총점, 평균 계산하여 화면에 출력

 

5. 성적 탐색 프로그램 
- 파일 이름을 argument로 전달받아 open

- n name  : 이름으로 성적을 찾아서, 있는 경우 화면에 출력, 없으면 '해당 학생의 성적은 없습니다.' 출력

-i id : 학번으로 성적을 찾아서, 있는 경우 화면에 출력, 없으면  '해당 학생의 성적은 없습니다.' 출력  

-o : 가장 성적이 좋은 학생을 찾아서 화면에 출력 (동점인 경우 마지막에 찾아진 학생 출력)

-s :  가장 성적이 좋은 학생을 찾아서 화면에 출력 (동점인 경우 모든 학생의 성적 출력)

<h3>구현</h3>

input.c

성적을 입력하는 input함수입니다. char*file로 main에서 argv[1]을 받아옵니다. (데이터파일)

score stu로 구조체를 선언해줍니다. fp파일포인터를 하나 선언해주고 file을 wb+권한으로 fopen합니다.

이때 open하지 못하여 null을 리턴받을시 오류메세지를 출력해주었습니다. open오류시 리턴값은 1로 통일해주었습니다

반복문으로 사용자에게 학생의 성적을 입력받습니다. memset으로 구조체를 초기화해준 후 scanf문으로 %d 형에대해서 값을 입력받습니다.

%s입력을 받을때는 fgets함수를 stdin입력으로 받아주었습니다. fgets함수는 엔터 입력또한 받으므로 개행문자를 삭제하기 위해

stu.name배열의 strlen-1값을 ‘\0’으로 할당해주었습니다. 그후 stu.all, stu.avg를 총점, 평균으로 저장해줍니다.

fwrite함수를 호출하여 stu구조체에 struct score의 사이즈만 큼 쓰기 해줍니다.

전에 배열을 쓰려다가 교수님께서 하나씩 받아 저장하면 된다는 조언을 받아 루프문을 돌리면 되겠다 생각하여 이렇게 작성하였습니다.

쓰기 작업이 끝나면 fclose를 이용해 fp를 닫아줍니다.


output.c

data출력함수인 output함수입니다. score stu로 구조체를 선언해줍니다. 파일포인터 fp와 fread함수 사용시 사용될 변수 n을 선언해줍니다.

fp로 main에서 받아온 데이터파일을 rb권한으로 열어줍니다. 이때 NULL리턴시 오류를 출 력해줍니다. 그후 1열에 학번 이름 국어 영어 수학 총점 평균을 출력해줍니다.

fread함수를 이용하여 score구조체크기만큼 fp에서 읽어옵니다. 이때 읽어온 stu.id, stu.name ... stu.avg를 출력 해줍니다.

이 함수는 더 이상 불러올 데이터가 없을때까지 while반목문에 의해 루프됩니다. 그렇기 때문에 입력단 계에서 입력한 데이터를 순차적으로 불러와 한줄씩 학생데이터를 출력합니다.


append.c

데이터를 추가하는 append함수입니다. 메인에서 데이터파일과 argv값을 불러와 함수에서 사용합니다.

먼저 추가하는 학생의 데이터를 출력하도록 해주었습니다. 단순한 메인에서 불러온 값들의 출력입니다.

argument로 총점과 평균은 받아오지 않았기 때문에 int all과 float avg를 선언하여 총점과 평균값을 저장해줍니다.

그리고 stu구조체를 선언해준뒤 fp파일포인터 선언후 데이터파일을 ab권한으로 열어줍니다.

ab권한은 append binary권한으로 기존파일을 유지한채 파일의 끝에서 추가합니다.

그후 stu.id...stu.avg값에 입력받은값을 저장합니다. stu.name의 경우 char *name 포인터형으로 받았기 때문에

반복문을 이용하여 값을 저장해주었습니다. 그후 fp를 닫아줍니다.


process.c

성적을 처리하는 process함수입니다. 메인에서 data파일을 받아 사용합니다. score stu로 stu구조체를 선언해줍니 다.

fp파일포인터를 선언해주고 fopen으로 데이터파일을 rb권한으로 열기합니다. 각 과목의 총점, 전체총점, 전체 평균을 저장할 변수들을 선언해줍니다.

fread함수를 score 구조체사이즈만큼 루프돌려 toal값들을 누적연산합니다. 이때 평균값을 구할 때 나눌 몫인 count도 count++를 해줍니다.

그후 총점과 평균부분을 총점=국어+수학+영어로 할당해주고 평균부분은 총점을 전 에 선언해주었던 count값으로 나눠주어 과목평균과 전체평균을 저장해줍니다.

그후 print문으로 해당 값들을 출력해주고 fp파일포인터를 닫아줍니다.


search.c

성적 검색함수 search함수입니다. stu구조체를 선언해줍니다. 그후 fread함수를 위한 변수n과 strcmp의 리턴값을 저장해줄 return_strcmp, atoi(optarg)를

저장할 search_id, 학생의 성적 존재 여부를 검사할 exist_check를 선언해 주었습니다. best_stu는 o옵션에서 1명만 출력하기위해 선언해주었고,

tmp는 평균을 이용하여 가장 좋은 성적의 학생을 탐색할 때 avg값을 임시로 저장하기 위해 사용하였습니다.

<옵션 n>

fp파일포인터를 선언해주고 optarg값을 strncpy를 이용하여 저장할 search_name을 선언해줍니다.

데이터를 rb권 한으로 열고 메인에서 getopt를 이용하여 받은 search_opt를 이용해 switch문을 돌려줍니다.

n인 경우 main에서 받은 optarg를 strncpy를 이용하여 search_name에 저장해줍니다. 그후 while반복문을 통해 fread함수를 호출하여

fp파일포인터가 가리키는파일을 score구조체의 사이즈만큼 구조체 stu에 읽어옵니다.

읽어오는 과정에서 name값이 일치하는지 검사하기위해 stcmp함수를 사용하여 stu.name과 search_name이 길이 와 내용이 동일한지 검사합니다.

이때 strcmp는 stu.name이 search_name보다 작은 경우 0보다 작은값, 같은 경 우 0, 큰 경우 0보다 큰값을 리턴하기 때문에 이 리턴값이 0인경우를 조건문을 걸어

printf문으로 해당 오프셋의 구조체를 출력해줍니다. 이때 exist_check값을 ++해줍니다. fread가 더 이상 읽어올것이없어 반복문이 종료되면

exist_check를 검사해줍니다. 하나라도 출력될 경우 ++해주었기 때문에 0인 경우 성적이 없다는 메시지를 출력합 니다.

<옵션 i>

기본적인 원리는 옵션n과 같습니다만, id의 경우는 int자료형이기 때문에 strncpy와 strcmp를 사용하지 않고 string 을 정수형으로 바꾸어주는 atoi함수를 사용하여

search_id에 optarg로 받은 학번을 int형으로 변환하여 저장시켜줍 니다. 그후 while문으로 fread함수를 돌려주고 stu.id가 search_id와 같은 경우

옵션n과 같이 해당 오프셋의 구조체 를 출력해주고 exist_check를 ++해줍니다. fread함수가 더 이상 읽을것이 없으면 while문을 탈출하고

exist_check 를 검사하게됩니다. 이때도 하나라도 출력될 경우 exist_check값이 ++되기 때문에 0인 경우 성적이 없음을 출력합 니다.

<옵션 o>

옵션 o는 가장 좋은 학생의 성적을 출력하는데 동점자가 있을시 마지막에 탐색한 학생을 출력하도록 합니다.

tmp 값을 0으로 초기화해주고 fread함수로 score구조체의 사이즈만큼 반복하여 불러옵니다. 이때 tmp값에 가장 높은 평균값을 저장하기위해

stu.avg와 tmp값을 비교해줍니다. 가장 높은 평균값을 저장하기 때문에 stu.avg>=tmp인 경우 tmp=stu.avg를 할당해주고,

이때 한학생만 출력해야하므로 이때 오프셋의 stu.id또한 best_stu에 저장합니다. 반대로 stu.avg가 tmp보다 작은 경우 tmp는 그대로 tmp입니다.

이렇게 루프문을 돌리게되면 가장 높은 성적이 tmp에 저장되게됩니다. 그후 fseek함수를 이용하여 fread하여 끝으로 이동한 오프셋을 다시 처음으로 돌려줍니다.

그후 다시 fread함수를 이용하여 아까 저장하였던 best_stu값을 stu.id와 비교하여 일치하는 경우 해당 오프셋의 stu구조체를 출력해줍니다.

<옵션 s>

옵션 s는 옵션o와 비슷하지만 동점자가있는 경우 모두 출력하도록 해주어야합니다. tmp를 0으로 초기화해주고 fread함수를 이용하여 data파일을 score구조체 사이즈만큼

stu에 읽어옵니다. 만약 stu.avg가 tmp보다 크거나 같 은 경우 tmp에 stu.avg를 저장해줍니다. 작다면 tmp는 tmp그대로입니다.

이렇게 루프문을 돌려 fread가 더 이상 읽어올것이 없게되면 탈출하게되고 tmp엔 가장높은성적의 평균이 저장됩니다.

fseek함수로 오프셋을 처음으로 되돌립니다. 그후 다시 fread함수를 호출하여 전에 저장하였던 tmp파일을 이용해 루프를 돌리며 stu.avg와 tmp를 검사해줍니다.

이때 두 개가 일치하는 경우 해당 오프셋의 구조체를 출력합니다. 이 경우 동점자도 같은 avg값을 가지고 있으므로 동점자 수 만큼 print문이 실행됩니다.
